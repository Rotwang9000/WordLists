<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>BIP39 Wordlist Converter</title>
	<style>
		* {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}
		
		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			min-height: 100vh;
			padding: 20px;
			color: #333;
		}
		
		.container {
			max-width: 900px;
			margin: 0 auto;
			background: white;
			border-radius: 12px;
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
			overflow: hidden;
		}
		
		.header {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			padding: 30px;
			text-align: center;
		}
		
		.header h1 {
			font-size: 2.5em;
			margin-bottom: 10px;
		}
		
		.header p {
			opacity: 0.9;
			font-size: 1.1em;
		}
		
		.content {
			padding: 30px;
		}
		
		.form-group {
			margin-bottom: 25px;
		}
		
		label {
			display: block;
			margin-bottom: 8px;
			font-weight: 600;
			color: #555;
		}
		
		select, textarea {
			width: 100%;
			padding: 12px;
			border: 2px solid #e0e0e0;
			border-radius: 8px;
			font-size: 16px;
			font-family: inherit;
			transition: border-color 0.3s;
		}
		
		select:focus, textarea:focus {
			outline: none;
			border-color: #667eea;
		}
		
		textarea {
			min-height: 150px;
			resize: vertical;
			font-family: 'Courier New', monospace;
		}
		
		.button-group {
			display: flex;
			gap: 15px;
			margin-bottom: 25px;
		}
		
		button {
			flex: 1;
			padding: 15px;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			color: white;
			border: none;
			border-radius: 8px;
			font-size: 16px;
			font-weight: 600;
			cursor: pointer;
			transition: transform 0.2s, box-shadow 0.2s;
		}
		
		button:hover {
			transform: translateY(-2px);
			box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
		}
		
		button:active {
			transform: translateY(0);
		}
		
		button.secondary {
			background: #6c757d;
		}
		
		button.secondary:hover {
			box-shadow: 0 5px 15px rgba(108, 117, 125, 0.4);
		}
		
		.result {
			margin-top: 25px;
			padding: 20px;
			background: #f8f9fa;
			border-radius: 8px;
			border-left: 4px solid #667eea;
		}
		
		.result h3 {
			margin-bottom: 15px;
			color: #667eea;
		}
		
		.result-text {
			background: white;
			padding: 15px;
			border-radius: 6px;
			font-family: 'Courier New', monospace;
			word-break: break-all;
			line-height: 1.6;
		}
		
		.info {
			background: #e7f3ff;
			border-left: 4px solid #2196F3;
			padding: 15px;
			border-radius: 6px;
			margin-bottom: 25px;
		}
		
		.info p {
			margin: 5px 0;
			color: #1976D2;
		}
		
		.error {
			background: #ffebee;
			border-left: 4px solid #f44336;
			padding: 15px;
			border-radius: 6px;
			margin-top: 15px;
			color: #c62828;
		}
		
		.hidden {
			display: none;
		}
	</style>
</head>
<body>
	<div class="container">
		<div class="header">
			<h1>üîê BIP39 Wordlist Converter</h1>
			<p>Convert between different BIP39 wordlists</p>
		</div>
		
		<div class="content">
			<div class="info">
				<p><strong>How it works:</strong> Enter a mnemonic phrase using one wordlist, select the source and target wordlists, then convert. The converter maps words by their position in each list.</p>
				<p><strong>Note:</strong> This tool works client-side - your phrases never leave your browser.</p>
			</div>
			
			<div class="form-group">
				<label for="sourceWordlist">Source Wordlist:</label>
				<select id="sourceWordlist">
					<option value="english">Standard English</option>
					<option value="swearwords">Swearwords</option>
					<option value="polari">Polari</option>
					<option value="esperanto">Esperanto</option>
					<option value="elder_futhark">Elder Futhark (Latin)</option>
					<option value="elder_futhark_runes">Elder Futhark (Runes)</option>
					<option value="emoji">Emoji</option>
					<option value="reverse_order_english">Reverse Order English</option>
					<option value="reversed_spelling_english">Reversed Spelling English</option>
				</select>
			</div>
			
			<div class="form-group">
				<label for="targetWordlist">Target Wordlist:</label>
				<select id="targetWordlist">
					<option value="english">Standard English</option>
					<option value="swearwords">Swearwords</option>
					<option value="polari">Polari</option>
					<option value="esperanto">Esperanto</option>
					<option value="elder_futhark">Elder Futhark (Latin)</option>
					<option value="elder_futhark_runes">Elder Futhark (Runes)</option>
					<option value="emoji">Emoji</option>
					<option value="reverse_order_english">Reverse Order English</option>
					<option value="reversed_spelling_english">Reversed Spelling English</option>
				</select>
			</div>
			
			<div class="form-group">
				<label for="inputPhrase">Enter Mnemonic Phrase:</label>
				<textarea id="inputPhrase" placeholder="Enter your mnemonic phrase here (space or newline separated)"></textarea>
			</div>
			
			<div class="button-group">
				<button onclick="convertPhrase()">Convert</button>
				<button class="secondary" onclick="clearAll()">Clear</button>
			</div>
			
			<div id="errorMessage" class="error hidden"></div>
			
			<div id="result" class="result hidden">
				<h3>Converted Phrase:</h3>
				<div id="resultText" class="result-text"></div>
			</div>
		</div>
	</div>
	
	<script>
		let wordlists = {};
		let loadingPromises = {};
		
		const wordlistFiles = {
			english: 'https://raw.githubusercontent.com/bitcoin/bips/master/bip-0039/english.txt',
			swearwords: 'swearwords.txt',
			polari: 'polari.txt',
			esperanto: 'esperanto.txt',
			elder_futhark: 'elder_futhark.txt',
			elder_futhark_runes: 'elder_futhark_runes.txt',
			emoji: 'emoji.txt',
			reverse_order_english: 'reverse_order_english.txt',
			reversed_spelling_english: 'reversed_spelling_english.txt'
		};
		
		async function loadWordlist(name) {
			if (wordlists[name]) {
				return wordlists[name];
			}
			
			if (loadingPromises[name]) {
				return loadingPromises[name];
			}
			
			loadingPromises[name] = fetch(wordlistFiles[name])
				.then(response => {
					if (!response.ok) {
						throw new Error(`Failed to load ${name} wordlist`);
					}
					return response.text();
				})
				.then(text => {
					const words = text.trim().split('\n').map(w => w.trim()).filter(w => w);
					if (words.length !== 2048) {
						console.warn(`Warning: ${name} wordlist has ${words.length} words, expected 2048`);
					}
					wordlists[name] = words;
					return words;
				})
				.catch(error => {
					delete loadingPromises[name];
					throw error;
				});
			
			return loadingPromises[name];
		}
		
		function showError(message) {
			const errorDiv = document.getElementById('errorMessage');
			errorDiv.textContent = message;
			errorDiv.classList.remove('hidden');
			document.getElementById('result').classList.add('hidden');
		}
		
		function hideError() {
			document.getElementById('errorMessage').classList.add('hidden');
		}
		
		async function convertPhrase() {
			hideError();
			
			const inputPhrase = document.getElementById('inputPhrase').value.trim();
			if (!inputPhrase) {
				showError('Please enter a mnemonic phrase');
				return;
			}
			
			const sourceName = document.getElementById('sourceWordlist').value;
			const targetName = document.getElementById('targetWordlist').value;
			
			if (sourceName === targetName) {
				showError('Source and target wordlists are the same');
				return;
			}
			
			try {
				// Show loading state
				const resultDiv = document.getElementById('result');
				const resultText = document.getElementById('resultText');
				resultText.textContent = 'Loading wordlists...';
				resultDiv.classList.remove('hidden');
				
				// Load both wordlists
				const [sourceWords, targetWords] = await Promise.all([
					loadWordlist(sourceName),
					loadWordlist(targetName)
				]);
				
				// Parse input phrase
				const inputWords = inputPhrase.split(/[\s\n]+/).map(w => w.trim().toLowerCase()).filter(w => w);
				
				if (inputWords.length === 0) {
					showError('No words found in input phrase');
					return;
				}
				
				// Convert each word
				const convertedWords = [];
				const errors = [];
				
				for (let i = 0; i < inputWords.length; i++) {
					const word = inputWords[i];
					const sourceIndex = sourceWords.indexOf(word);
					
					if (sourceIndex === -1) {
						errors.push(`Word "${word}" not found in source wordlist (position ${i + 1})`);
						continue;
					}
					
					if (sourceIndex >= targetWords.length) {
						errors.push(`Source word index ${sourceIndex} exceeds target wordlist length (position ${i + 1})`);
						continue;
					}
					
					convertedWords.push(targetWords[sourceIndex]);
				}
				
				if (errors.length > 0) {
					showError('Conversion errors:\n' + errors.join('\n'));
					if (convertedWords.length > 0) {
						resultText.textContent = convertedWords.join(' ');
					}
					return;
				}
				
				// Display result
				resultText.textContent = convertedWords.join(' ');
				resultDiv.classList.remove('hidden');
				
			} catch (error) {
				showError(`Error: ${error.message}`);
				console.error(error);
			}
		}
		
		function clearAll() {
			document.getElementById('inputPhrase').value = '';
			document.getElementById('result').classList.add('hidden');
			hideError();
		}
		
		// Allow Enter key to trigger conversion (Ctrl+Enter or Cmd+Enter)
		document.getElementById('inputPhrase').addEventListener('keydown', function(e) {
			if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
				convertPhrase();
			}
		});
	</script>
</body>
</html>

